{
    "add": "\n\nvoid add(Bighex a, Bighex b) {\n\tint jw = 0;\n\tfor (int i = 0; i < LEN; ++i) {\n\t\ta[i] += b[i] + jw;\n\t\tjw = a[i] >> SHF;\n\t\ta[i] &= MXW;\n\t}\n}",
    "sub": "\nvoid sub(Bighex a, Bighex b) {\n\tint jw = 0;\n\tfor (int i = 0; i < LEN; ++i) {\n\t\ta[i] -= b[i];\n\t\tif (a[i] < 0) {\n\t\t\ta[i] += (MXW + 1);\n\t\t\t--a[i + 1];\n\t\t}\n\t}\n}",
    "sub1": "\nvoid sub1(Bighex a) {\n\tfor (int i = 0; i < LEN; ++i) {\n\t\t--a[i];\n\t\tif (!~a[i]) a[i] = MXW;\n\t\telse break;\n\t}\n}",
    "output": "\nvoid output(Bighex a) {\n    for (int i = 36; ~i; --i) {\n        if (i == 36) printf(\"%04llx\", a[i]);\n        else printf(\"%07llx\", a[i]);\n    }\n    puts(\"\");\n}",
    "mul": "\nvoid mul(Bighex a, Bighex b) {\n\tstatic Bighex c;\n\tfor (int i = 0; i < LEN; ++i) c[i] = 0;\n\tfor (int i = 0; i < LENDIV2; ++i) for (int j = 0; j < LENDIV2; ++j) c[i + j] += a[i] * b[j];\n\tfor (int i = 0; i < LEN; ++i) a[i] = (c[i] & MXW), c[i + 1] += (c[i] >> SHF);\n}",
    "greater_or_equal": "\nchar greater_or_equal(Bighex a, Bighex b, int lst, int len, int low) {\n\tif (a[lst + len]) return 1;\n\tfor (int i = len - 1; i >= low; --i) {\n\t\tif (a[lst + i] > b[i]) return 1;\n\t\tif (a[lst + i] < b[i]) return 0;\n\t}\n\treturn 1;\n}",
    "div2": "\nvoid div2(Bighex a) {\n\tfor (int i = 0; i < LEN - 1; ++i) a[i] = (a[i] >> 1) | ((a[i + 1] & 1) << (SHF - 1));\n\ta[LEN - 1] >>= 1;\n}",
    "mul2": "\nvoid mul2(Bighex a) {\n\tfor (int i = LEN - 1; i; --i) a[i] = ((a[i] << 1) & MXW) | (a[i - 1] >> (SHF - 1));\n\ta[0] <<= 1; a[0] &= MXW;\n}",
    "divd": "\n\nvoid divd(Bighex a, Bighex b, Bighex res) {\n\tfor (int i = 0; i < LENDIV2; ++i) b[i + LENDIV2] = b[i], b[i] = 0;\n\tfor (int i = 0; i < LEN; ++i) res[i] = 0;\n\tfor (int i = 0; i <= LENDIV2 * SHF; ++i) {\n\t\tif (greater_or_equal(a, b, 0, LEN, 0)) {\n\t\t\tfor (int j = 0; j <= LEN; ++j) {\n\t\t\t\ta[j] -= b[j];\n\t\t\t\tif (a[j] < 0) {\n\t\t\t\t\ta[j] += MXW + 1;\n\t\t\t\t\t--a[j + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[0] |= 1;\n\t\t}\n\t\tif (i != LENDIV2 * SHF) div2(b), mul2(res);\n\t}\n}",
    "mod": "\n\nvoid mod(Bighex a, Bighex b) {\n\t\tstatic Bighex q, qq, r1, r2, r3;\n\tfor (int i = 0; i < LEN; ++i) q[i] = r1[i] = r2[i] = r3[i] = qq[i] = 0;\n\tfor (int i = 18; i < LEN; ++i) q[i - 18] = a[i];\n\tmul(q, birm);\n\tfor (int i = 20; i < LEN; ++i) qq[i - 20] = q[i];\n\tfor (int i = 0; i < 20; ++i) r1[i] = a[i];\n\tfor (int i = 0; i < LEN; ++i) r2[i] = qq[i];\n\tmul(r2, b);\n\tfor (int i = 0; i < 20; ++i) r3[i] = r2[i];\n\tsub(r1, r3);\n\tif (greater_or_equal(r1, b, 0, LEN, 0)) sub(r1, b);\n\tfor (int i = 0; i < LEN; ++i) a[i] = r1[i];\n\t\t\t\t}",
    "is_odd": "\nchar is_odd(Bighex a) {\n\treturn !(a[0] & 1);\n}",
    "is_0": "\nchar is_0(Bighex a) {\n\tfor (int i = 0; i < LEN; ++i) if (a[i]) return 0;\n\treturn 1;\n}",
    "is_1": "\nchar is_1(Bighex a) {\n\tif (a[0] != 1) return 0;\n\tfor (int i = 1; i < LEN; ++i) if (a[i]) return 0;\n\treturn 1;\n}",
    "is_n_minus_1": "\nchar is_n_minus_1(Bighex a, Bighex n) {\n\tstatic Bighex na;\n\tfor (int i = 0; i < LEN; ++i) na[i] = n[i];\n\tsub1(na);\n\tfor (int i = 0; i < LEN; ++i) if (na[i] != a[i]) return 0;\n\treturn 1;\n}",
    "qpow": "\nvoid qpow(Bighex a, Bighex b, Bighex m, Bighex res) {\n\tif (is_0(b)) {\n\t\tfor (int i = 0; i < LEN; ++i) res[i] = 0;\n\t\tres[0] = 1;\n\t\treturn;\n\t}\n\tchar odd = is_odd(b);\n\tdiv2(b);\n\tqpow(a, b, m, res);\n\tmul(res, res);\n\tmod(res, m);\n\tif (odd) {\n\t\tmul(res, a);\n\t\tmod(res, m);\n\t}\n}",
    "tran": "\nint tran(Bighex x) {\n\t\t\t\treturn x[0];\n}",
    "randomize": "\nint randomize() {\n\tif (RAND_MAX > (1 << 28)) return rand() % (1 << 28);\n\telse return (rand() * 11451 + rand() + 4) % (1 << 28);\n}",
    "miller_rabin": "\nchar miller_rabin(Bighex n, int times, char debug) {\n\tfor (int i = 0; i < LEN; ++i) re[i] = 0;\n\tre[38] = 1;\n\tdivd(re, n, birm);\n\tstatic Bighex a, aa, v, x;\n\tchar issuc = 1;\n\tfor (int i = 0; i < LEN; ++i) a[i] = n[i];\n\tsub1(a); int b = 0;\n\twhile (!is_odd(a)) div2(a), ++b;\n\tfor (int i = 0; i < times; ++i) {\n\t\tx[0] = randomize();\n\t\t\t\tif (x[0] < 2) x[0] = 2;\n\t\tfor (int i = 0; i < LEN; ++i) aa[i] = a[i];\n\t\tqpow(x, aa, n, v);\n\t\tif (is_1(v) || is_n_minus_1(v, n)) {\n\t\t\tif (debug) {\n\t\t\t\tprintf(\"Success: %d\\n\", tran(x));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tchar ok = 0;\n\t\tfor (int j = 0; j < b; ++j) {\n\t\t\tmul(v, v);\n\t\t\tmod(v, n);\n\t\t\tif (is_n_minus_1(v, n)) {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tif (debug) {\n\t\t\t\tprintf(\"Failed: %d\\n\", tran(x));\n\t\t\t\tissuc = 0;\n\t\t\t}\n\t\t\telse return 0;\n\t\t}\n\t\telse {\n\t\t\tif (debug) {\n\t\t\t\tprintf(\"Success: %d\\n\", tran(x));\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}",
    "genRand": "\n\nvoid genRand(Bighex x) {\n\tll vsum = 0;\n\tvsum = x[0] = (randomize() % (1 << 26)) * 4 + 3;\n\tfor (int i = 1; i <= 17; ++i) x[i] = randomize(), vsum += x[i];\n\tx[18] = rand() % 64 + 64 * 3;\n\twhile ((x[18] + vsum) % 3 == 0 || (x[18] + vsum) % 5 == 0) x[18] = rand() % 64 + 64 * 3;\n}",
    "main": "\nint main(int argc, char **argv) {\n\tsrand(time(NULL));\n\tgenRand(a);\n\twhile (!miller_rabin(a, 10, 0)) {\n\t\tgenRand(a);\n\t}\n\tgenRand(b);\n\twhile (!miller_rabin(b, 10, 0)) {\n\t\tgenRand(b);\n\t}\n\tLEN >>= 1;\n    printf(\"Number A: \");\n    output(a);\n    printf(\"Number B: \");\n    output(b);\n\tLEN <<= 1;\n\tmul(a);\n\toutput(a);\n\tprintf(\"Time used: %.3lfs\\n\", 1. * clock() / CLOCKS_PER_SEC);\n\tLEN <<= 1; LENDIV2 <<= 1;\n\tmiller_rabin(a, 20, 1);\n\treturn 0;\n}"
}